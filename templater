#!/usr/bin/env ruby
require 'json'

if(ARGV.length != 3)
  raise ArgumentError, "Provide exactly 3 arguments."
end
if(File.exist?(ARGV[2]))
  raise IOError, "Could not create output file. File \"#{ARGV[2]}\" already exists."
end

class DataObject
  def initialize(json_file)
    File.open(json_file, "r") do |file|
      @data = JSON.parse(file.read)
    end
    unless(@data.is_a?(Hash))
      raise IOError, "JSON Error: #{ARGV[1]} was not a valid data file for this operation, root must be an Object." 
    end
  end

  # Parse a lookup from the json
  def find(chain, from=@data, history=[])
    key = chain.first
    chain = chain.slice(1..-1)
    if(key.is_a?(String))
      unless(from.is_a?(Hash))
        raise "Template Error: '#{(history).join('.')}' was not an object."
      end
    elsif(key.is_a?(Integer))
      unless(from.is_a?(Array))
        raise "Template Error: '#{(history).join('.')}' was not an array."
      end
    else
      raise "Internal Error: Unexpected key value."
    end

    value_for_found = from[key]
    history << key
    if(value_for_found.nil?)
      raise "Template Error: Could not find a value for '#{(history).join('.')}'."
    elsif(!chain.empty?)
      return self.find(chain, value_for_found, history)
    else
      return value_for_found
    end
  end
end

class TextElement
  attr_reader :value
  
  def initalize(value)
    @value = value
  end
end

class EachElement
  attr_reader :path, :element_name
  def initialize(path, element_name)
    @path = path
    @element_name = element_name
  end
end

class EvalElement
  attr_reader :path
  def initialize(path)
    @path = path
  end
end


# Get html data
html_text = ""
File.open(ARGV[0], "r") do |file|
  html_text = file.read
end

data = DataObject.new(ARGV[1])

# Break up html file into a document with structure
html_document = []
remainder = html_text
finished = false
until(finished)
  # Break the unparsed section of the file into three pieces, before, after, and equal to the next tag
  partition_result = remainder.partition(/<\*.*?\*>/)
  # Save the first element to our object as type 'text'
  html_document << {:type => 'text', :value => partition_result[0]}

  # Save the second element to our object as type "eval"
  found = partition_result[1]
  if(!found.empty?)
    # Remove the tag openers and closes
    found = found.slice(2..-3)
    found.strip!
    words = found.split(" ")
    words.map! do |word|
      word.strip.split(".")
    end
    # If the first element's first word is "EACH", set type to 'start_each' and remove it
    # If the first element's first word is "ENDEACH", set type to 'end_each' and remove it
    # Otherwise, set type to 'eval'
    # Undo our previous split for the first word only - this should not do anything unless the template is wrong
    first_word = words.first.join(".")
    if("EACH" == first_word)
      # We already know what the first argument is, so dump it
      words.shift
      if(words.length != 2)
        raise "Template Error: EACH statements require exactly two arguments, a target array and a variable to use as context for inside the loop."
      end
      target = words.shift
      context = words.shift
      if(context.length > 1)
        raise "Template Error: EACH statements cannot have their values assigned to a variable chain."
      end
      html_document << {:type => 'start_each', :value => target, :replace => context.first}
    elsif("ENDEACH" == first_word)
      words.shift
      if(words.length > 0)
        raise "Template Error: ENDEACH statements cannot take arguments."
      end
      html_document << {:type => 'end_each'}
    elsif(words.length > 1)
      raise "Template Error: Could not figure out the logic for '#{words.flatten}'. Did you really intend to use spaces, here?"
    else
      html_document << {:type => 'eval', :value => words.first}
    end
  else
    finished = true
  end
  remainder = partition_result[2]
  if(remainder.empty?)
    finished=true
  end
end

# Crawl through the document and remove EACH/ENDEACH pairs, and everything inside them, from the document flow
nested_content = [{:content => []}]
html_document.each do |element|
  if('start_each' == element[:type])
    # When we encounter an EACH, find the associated value
    found_array = data.find(element[:value])
    if(!found_array.is_a?(Array))
      raise "Template Error: '#{element[:value]}' is not an array. EACH only works with arrays."
    end
    nested_content << {:duplicates => found_array.length, :content => [], :replace => element[:replace], :with => element[:value]}
  elsif('end_each' == element[:type])
    # When we encounter an ENDEACH, execute the associated loop
    if(nested_content.length <= 1)
      raise "Template Error: Unmatched ENDEACH."
    else
      newest_loop = nested_content.pop
      # Replace any elements with a fully expanded path to the current array element, and then add to the parent content
      newest_loop[:duplicates].times do |index|
        content_iteration = []
        newest_loop[:content].each do |inner_element|
          if( ('eval' == inner_element[:type]) && (inner_element[:value].first == newest_loop[:replace]) )
            ending = inner_element[:value].slice(1..-1)
            new_path = newest_loop[:with]+[index]+ending
            content_iteration << { :type => inner_element[:type], :value => new_path }
          else
            content_iteration << inner_element
          end
        end
        nested_content.last[:content] = nested_content.last[:content].concat(content_iteration)
      end
    end

  else
    # Otherwise, insert the value into the current content
    nested_content.last[:content] << element
  end
end

if(nested_content.length > 1)
  raise "Template Error: Unmatched EACH"
end

html_document = nested_content.pop[:content]

# Crawl through the document and conduct replacements
html_document.each_with_index do |element, index|
  if('eval' == element[:type])
    string_found = data.find(element[:value])
    if(string_found.is_a?(String))
      html_document[index] = {:type => 'text', :value => string_found}
    else
      raise "Template Error: Value for '#{element[:value]}' was not a String."
    end
  end
end

# Convert the document structure back to flat plaintext
html_text = html_document.map{|element| element[:value]}.join("")

# Write output
printf html_text
#File.open(ARGV[2], "w") do |file|
#  file.write(html_object.join(""))
#end

