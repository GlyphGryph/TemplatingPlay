#!/usr/bin/env ruby
require 'json'

if(ARGV.length != 3)
  raise ArgumentError, "Provide exactly 3 arguments."
end
if(File.exist?(ARGV[2]))
  raise IOError, "Could not create output file. File \"#{ARGV[2]}\" already exists."
end

# Get html data
html_text = ""
File.open(ARGV[0], "r") do |file|
  html_text = file.read
end

# Get json
data_object = {}
File.open(ARGV[1], "r") do |file|
  data_object = JSON.parse(file.read)
end
if(!data_object.is_a?(Hash))
  raise IOError, "JSON Error: #{ARGV[1]} was not a valid data file for this operation, root must be an Object." 
end

# Parse a lookup from the json
def find_nested_value(chain, from, history=[])
  value_for_found = from[chain.first]
  if(value_for_found.nil?)
    raise "Template Error: Could not find a value for '#{(history << chain.first).join('.')}'."
  elsif(value_for_found.is_a?(String))
    return value_for_found
  elsif(value_for_found.is_a?(Hash))
    history << chain.shift
    if(chain.empty?)
      raise "Template Error: Expected value for '#{(history << chain.first).join('.')}' to be a string, but it was an object."
    end
    return find_nested_value(chain, value_for_found, history)
  else
    raise "Template Error: Value for '#{found}' was not a String."
  end
end

# Break up html file into a document with structure
html_document = []
remainder = html_text
finished = false
until(finished)
  # Break the unparsed section of the file into three pieces, before, after, and equal to the next tag
  partition_result = remainder.partition(/<\*.*?\*>/)
  # Save the first element to our object as type 'text'
  html_document << {:type => 'text', :value => partition_result[0]}

  # Save the second element to our object as type "eval"
  found = partition_result[1]
  if(!found.empty?)
    # Remove the tag openers and closes
    found = found.slice(2..-3)
    found.strip!
    found = found.split(".")
    # Dig to find the value of this tag
    html_document << {:type => 'eval', :value => found}
  else
    finished = true
  end
  remainder = partition_result[2]
  if(remainder.empty?)
    finished=true
  end
end

# Crawl through the document and conduct replacements
html_document.each_with_index do |element, index|
  if('eval' == element[:type])
    html_document[index] = {:type => 'text', :value => find_nested_value(element[:value], data_object)}
  end
end

# Convert the document structure back to flat plaintext
html_text = html_document.map{|element| element[:value]}.join("")

# Write output
p html_text
#File.open(ARGV[2], "w") do |file|
#  file.write(html_object.join(""))
#end
